---
title: Architecture and Design
slug: /v3/getting-started/architecture
version: '3.0'
section: docs
category: getting started
keywords:
---

![Substrate Client Architecture](../../../../src/images/docs/getting-started/substrate-arch.png)

The Substrate [client](/v3/glossary#node) is an application that runs a Substrate-based blockchain node.
It consists of several components that include, but are not limited to, the following:

- **Storage**: used to persist the evolving state of a Substrate blockchain. The
  blockchain network allows participants to reach trustless [consensus](/v3/advanced/consensus) about the
  state of storage. Substrate ships with a simple and highly efficient
  [key-value storage mechanism](/v3/advanced/storage).
- **Runtime**: the logic that defines how blocks are processed, including state transition logic. In Substrate, runtime code is
  compiled to [Wasm](/v3/getting-started/glossary#webassembly-wasm) and becomes part of the blockchain's
  storage state. This enables one of the defining features of a Substrate-based blockchain:
  [forkless runtime upgrades](/v3/runtime/upgrades#forkless-runtime-upgrades). Substrate clients may also
  include a "native runtime" that is compiled for the same platform as the client itself (as opposed to Wasm). The
  component of the client that dispatches calls to the runtime is known as the
  [executor](/v3/advanced/executor), whose role is to select between the native code and interpreted Wasm. Although the
  native runtime may offer a performance advantage, the executor will select to interpret the Wasm runtime if it
  implements a newer [version](/v3/runtime/upgrades#runtime-versioning).
- **Peer-to-peer network**: the capabilities that allow the client to communicate with other network participants. Substrate uses
  the Rust implementation of the [`libp2p` network stack](https://libp2p.io/) to achieve this.
- **Consensus**: the logic that allows network participants to agree on the state of the blockchain.
  Substrate makes it possible to supply custom consensus engines and also ships with several consensus mechanisms that
  have been built on top of [Web3 Foundation research](https://w3f-research.readthedocs.io/en/latest/index.html).
- **RPC** (remote procedure call): the capabilities that allow blockchain users to interact with the network. Substrate provides
  HTTP and WebSocket RPC servers.
- **Telemetry**: client metrics that are exposed by the embedded [Prometheus](https://prometheus.io/) server.

For many custom chains, the _runtime_ is the focus of development. This is the novel logic that makes your chain unique. This typically drives all other development efforts for the client, and typically those components need relatively minor changes to enable your end use cases.

## Runtime Design choices

Substrate empowers developers to make choices between _technical freedom and ease of development_ in every step of their blockchain's design.
Substrate is designed to be used in one of three, progressively harder and more powerful ways:

1. **Use the Substrate Node**: You can run the pre-designed [Substrate Node](https://github.com/paritytech/substrate/tree/master/bin/node) and [configure](https://github.com/paritytech/substrate/blob/master/bin/node/cli/src/chain_spec.rs) its genesis block.
   In this case, you just need to supply a JSON file and launch your own blockchain.
   The JSON file allows you to configure the genesis state of the modules that compose the Substrate Node's runtime, such as: Balances, Staking, and Sudo.
   You can learn more about running a Substrate node in the [Create Your First Substrate Chain](/tutorials/v3/create-your-first-substrate-chain) and [Start a Private Network](/tutorials/v3/private-network) tutorials.

2. **Compose and customize a Substrate FRAME node**: You can easily compose an extend a own custom blockchain using [FRAME](/v3/runtime/frame) (Framework for Runtime Aggregation of Modularized Entities), which is what is used to build the Substrate Node.
   This affords you a large amount of freedom over your blockchain's logic, and allows you to configure data types, select from a libraries of modules (called "pallets"), and continent methods write your own custom pallets. The
   [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template) is a helpful starting point for projects like this. To learn more, see the tutorials to [Build a dApp](/tutorials/v3/proof-of-existence) and [Add a Pallet](/tutorials/v3/add-a-pallet).

3. **Build a node with Substrate Core**: The entire FRAME system can be ignored, and the runtime can be designed and implemented from scratch.
   This could be done in _any language_ that can target [WebAssembly](https://webassembly.org/).
   If the runtime can be made to be compatible with the abstract block authoring logic of the Substrate node, then you can simply construct a new genesis block from your Wasm blob and launch your chain with the existing Rust-based Substrate client.
   If not, then you will need to alter the client's block authoring logic, and potentially even alter the header and block serialization formats.

As you move into these docs, note that most are centered on FRAME based development.
Most use cases are covered by this intermediate level quite well, and when needed, only minor modification to things outside FRAME are required, as opposed to full Core driven development.